<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geocoding Process: Detailed Flow Diagrams</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
            min-height: 100vh;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        nav {
            background: #2c3e50;
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }

        nav a {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            transition: background 0.3s;
        }

        nav a:hover {
            background: rgba(255,255,255,0.2);
        }

        main {
            padding: 2rem;
        }

        section {
            margin-bottom: 4rem;
            scroll-margin-top: 100px;
        }

        section h2 {
            color: #667eea;
            font-size: 2rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #667eea;
        }

        section h3 {
            color: #764ba2;
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .diagram-container {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow-x: auto;
        }

        .mermaid {
            text-align: center;
            background: white;
            padding: 1rem;
            border-radius: 5px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        table th, table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        table th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        table tr:hover {
            background: #f8f9fa;
        }

        code {
            background: #f4f4f4;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 1.5rem;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1.5rem 0;
        }

        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 5px;
        }

        .success-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 5px;
        }

        .example-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 5px;
        }

        ul, ol {
            margin-left: 2rem;
            margin-top: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        .back-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: #667eea;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            transition: transform 0.3s;
        }

        .back-to-top:hover {
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8rem;
            }

            nav ul {
                flex-direction: column;
            }

            .diagram-container {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç Geocoding Process</h1>
            <p>Detailed Flow Diagrams - "Hai Masana area, Wau Town, Wau County"</p>
        </header>

        <nav>
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#main-flow">Main Flow</a></li>
                <li><a href="#normalization">Normalization</a></li>
                <li><a href="#constraints">Constraints</a></li>
                <li><a href="#candidates">Candidates</a></li>
                <li><a href="#resolution">Resolution</a></li>
                <li><a href="#village-search">Village Search</a></li>
                <li><a href="#fuzzy-matching">Fuzzy Matching</a></li>
                <li><a href="#context-boost">Context Boost</a></li>
                <li><a href="#example">Example</a></li>
                <li><a href="#data-flow">Data Flow</a></li>
                <li><a href="#error-handling">Error Handling</a></li>
                <li><a href="#performance">Performance</a></li>
                <li><a href="#summary">Summary</a></li>
            </ul>
        </nav>

        <main>
            <section id="overview">
                <h2>Overview</h2>
                <div class="info-box">
                    <p>This presentation provides detailed diagrams and explanations of the geocoding process for the address: <strong>"Hai Masana area, Wau Town, Wau County"</strong>.</p>
                    <p>The geocoding system uses a hierarchical resolution approach, trying to match locations from most specific (villages) to least specific (counties), with intelligent constraint validation and fuzzy matching.</p>
                </div>
            </section>

            <section id="architecture">
                <h2>1. High-Level Architecture</h2>
                <div class="diagram-container">
                    <div class="mermaid">
graph TB
    A[User Input:<br/>Hai Masana area, Wau Town, Wau County] --> B[Geocoder.geocode]
    B --> C[Text Normalization]
    C --> D[Cache Check]
    D --> E{Has Constraints?}
    E -->|Yes| F[Skip Cache]
    E -->|No| G{Cache Hit?}
    G -->|Yes| H[Return Cached Result]
    G -->|No| F
    F --> I[Parse Hierarchical Constraints]
    I --> J[Extract Candidates]
    J --> K[Load Admin Layers]
    K --> L[Hierarchical Resolution]
    L --> M[Cache Result]
    M --> N[Return GeocodeResult]
                    </div>
                </div>
            </section>

            <section id="main-flow">
                <h2>2. Main Geocoding Flow</h2>
                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    Start([Start: geocode function]) --> Norm[normalize_text<br/>'hai masana area wau town wau county']
    Norm --> Parse[parse_hierarchical_constraints]
    Parse --> CheckCache{Has Constraints?}
    CheckCache -->|Yes| SkipCache[Skip Cache<br/>Avoid stale results]
    CheckCache -->|No| CacheLookup[Check geocode_cache table]
    CacheLookup --> CacheHit{Cache Found?}
    CacheHit -->|Yes| ReturnCache[Return Cached Result]
    CacheHit -->|No| SkipCache
    SkipCache --> LoadLayers[_load_admin_layers<br/>Load from DuckDB]
    LoadLayers --> ExtractCandidates[extract_candidates<br/>Generate n-grams]
    ExtractCandidates --> AIExtract{Azure AI Enabled?}
    AIExtract -->|Yes| AICall[Azure AI Extraction<br/>Merge with candidates]
    AIExtract -->|No| Resolve
    AICall --> Resolve[_resolve_hierarchical]
    Resolve --> TryVillage[_try_settlement_match]
    TryVillage --> VillageFound{Village Match?}
    VillageFound -->|Yes| ReturnVillage[Return Village Result]
    VillageFound -->|No| TryBoma[_try_polygon_match<br/>admin4_boma]
    TryBoma --> BomaFound{Boma Match?}
    BomaFound -->|Yes| ReturnBoma[Return Boma Result]
    BomaFound -->|No| TryPayam[_try_polygon_match<br/>admin3_payam]
    TryPayam --> PayamFound{Payam Match?}
    PayamFound -->|Yes| ReturnPayam[Return Payam Result]
    PayamFound -->|No| TryCounty[_try_polygon_match<br/>admin2_county]
    TryCounty --> CountyFound{County Match?}
    CountyFound -->|Yes| ReturnCounty[Return County<br/>resolution_too_coarse=True<br/>No coordinates]
    CountyFound -->|No| NoMatch[Return No Match<br/>score=0.0]
    ReturnVillage --> CacheResult[Cache Result]
    ReturnBoma --> CacheResult
    ReturnPayam --> CacheResult
    ReturnCounty --> CacheResult
    NoMatch --> CacheResult
    CacheResult --> End([End])
    ReturnCache --> End
                    </div>
                </div>
            </section>

            <section id="normalization">
                <h2>3. Text Normalization Process</h2>
                <div class="diagram-container">
                    <div class="mermaid">
graph LR
    A["Input:<br/>'Hai Masana area, Wau Town, Wau County'"] --> B[Unicode Normalization<br/>NFD ‚Üí Remove Diacritics]
    B --> C[Lowercase Conversion]
    C --> D[Handle Abbreviations<br/>c equatoria ‚Üí central equatoria]
    D --> E[Handle Transliterations<br/>waw ‚Üí wau]
    E --> F[Protect Preserve Words<br/>el, al, de, la]
    F --> G[Remove Punctuation]
    G --> H[Restore Preserve Words]
    H --> I[Collapse Whitespace]
    I --> J["Output:<br/>'hai masana area wau town wau county'"]
                    </div>
                </div>

                <h3>Normalization Details</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Step</th>
                            <th>Input</th>
                            <th>Output</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1. Unicode</td>
                            <td><code>Hai Masana</code></td>
                            <td><code>Hai Masana</code></td>
                            <td>Remove diacritics</td>
                        </tr>
                        <tr>
                            <td>2. Lowercase</td>
                            <td><code>Hai Masana</code></td>
                            <td><code>hai masana</code></td>
                            <td>Convert to lowercase</td>
                        </tr>
                        <tr>
                            <td>3. Abbreviations</td>
                            <td><code>c equatoria</code></td>
                            <td><code>central equatoria</code></td>
                            <td>Expand abbreviations</td>
                        </tr>
                        <tr>
                            <td>4. Transliterations</td>
                            <td><code>waw</code></td>
                            <td><code>wau</code></td>
                            <td>Normalize spellings</td>
                        </tr>
                        <tr>
                            <td>5. Remove Punctuation</td>
                            <td><code>area, Wau</code></td>
                            <td><code>area wau</code></td>
                            <td>Remove commas, periods</td>
                        </tr>
                        <tr>
                            <td>6. Collapse Whitespace</td>
                            <td><code>area  wau</code></td>
                            <td><code>area wau</code></td>
                            <td>Single spaces</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="constraints">
                <h2>4. Hierarchical Constraint Parsing</h2>
                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    Input["Input:<br/>'Hai Masana area, Wau Town, Wau County'"] --> Split[Split by Delimiters<br/>comma, semicolon]
    Split --> Part1["Part 1:<br/>'Hai Masana area'"]
    Split --> Part2["Part 2:<br/>'Wau Town'"]
    Split --> Part3["Part 3:<br/>'Wau County'"]
    
    Part1 --> Check1{Contains Keywords?}
    Check1 -->|town, village, city| Village1[Set village = 'hai masana area']
    Check1 -->|No keywords| Infer1[Infer: First part = village]
    
    Part2 --> Check2{Contains Keywords?}
    Check2 -->|town| Village2[Set village = 'wau']
    Check2 -->|No| Infer2[Infer: Second part = village]
    
    Part3 --> Check3{Contains Keywords?}
    Check3 -->|county| County[Set county = 'wau']
    Check3 -->|No| Infer3[Infer: Last part = county]
    
    Village1 --> Merge[Merge Constraints]
    Village2 --> Merge
    Infer1 --> Merge
    Infer2 --> Merge
    County --> Merge
    Infer3 --> Merge
    
    Merge --> Result["Constraints:<br/>{<br/>  village: 'hai masana area',<br/>  county: 'wau',<br/>  state: None,<br/>  payam: None,<br/>  boma: None<br/>}"]
                    </div>
                </div>

                <div class="example-box">
                    <h3>Constraint Parsing Logic</h3>
                    <pre><code># Pseudo-code for parse_hierarchical_constraints()

parts = ["Hai Masana area", "Wau Town", "Wau County"]
constraints = {
    "state": None,
    "county": None,
    "payam": None,
    "boma": None,
    "village": None
}

for part in parts:
    normalized = normalize_text(part)
    
    if "county" in normalized:
        constraints["county"] = "wau"  # Remove "county" keyword
    
    if "town" in normalized:
        constraints["village"] = "wau"  # Remove "town" keyword
    
    if no_keywords and is_first_part:
        constraints["village"] = "hai masana area"

# Final constraints:
# {
#   "village": "hai masana area",  # From first part
#   "county": "wau",                # From "Wau County"
#   "state": None,
#   "payam": None,
#   "boma": None
# }</code></pre>
                </div>
            </section>

            <section id="candidates">
                <h2>5. Candidate Extraction Process</h2>
                <div class="diagram-container">
                    <div class="mermaid">
graph TD
    A["Normalized Text:<br/>'hai masana area wau town wau county'"] --> B[Split into Words]
    B --> C["Words:<br/>['hai', 'masana', 'area', 'wau', 'town', 'wau', 'county']"]
    C --> D[Generate N-grams]
    
    D --> E[Single Words<br/>min_length >= 3]
    E --> E1["'hai'<br/>'masana'<br/>'area'<br/>'wau'<br/>'town'<br/>'county'"]
    
    D --> F[2-word N-grams]
    F --> F1["'hai masana'<br/>'masana area'<br/>'area wau'<br/>'wau town'<br/>'town wau'<br/>'wau county'"]
    
    D --> G[3-word N-grams]
    G --> G1["'hai masana area'<br/>'masana area wau'<br/>'area wau town'<br/>'wau town wau'<br/>'town wau county'"]
    
    D --> H[Full Text]
    H --> H1["'hai masana area wau town wau county'"]
    
    E1 --> Filter[Filter Stop Words]
    F1 --> Filter
    G1 --> Filter
    H1 --> Filter
    
    Filter --> Candidates["Candidates Set:<br/>{<br/>  'hai', 'masana', 'area',<br/>  'wau', 'town', 'county',<br/>  'hai masana', 'masana area',<br/>  'area wau', 'wau town',<br/>  'wau county',<br/>  'hai masana area',<br/>  'wau town',<br/>  ...<br/>}"]
                    </div>
                </div>

                <h3>N-gram Generation Example</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Examples</th>
                            <th>Count</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1-gram</td>
                            <td><code>hai</code>, <code>masana</code>, <code>area</code>, <code>wau</code>, <code>town</code>, <code>county</code></td>
                            <td>6</td>
                        </tr>
                        <tr>
                            <td>2-gram</td>
                            <td><code>hai masana</code>, <code>masana area</code>, <code>area wau</code>, <code>wau town</code>, <code>wau county</code></td>
                            <td>5</td>
                        </tr>
                        <tr>
                            <td>3-gram</td>
                            <td><code>hai masana area</code>, <code>masana area wau</code>, <code>area wau town</code>, <code>wau town wau</code></td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>4-gram</td>
                            <td><code>hai masana area wau</code>, <code>masana area wau town</code></td>
                            <td>2</td>
                        </tr>
                        <tr>
                            <td>Full</td>
                            <td><code>hai masana area wau town wau county</code></td>
                            <td>1</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="resolution">
                <h2>6. Hierarchical Resolution Decision Tree</h2>
                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    Start([Start Resolution]) --> Village[_try_settlement_match]
    Village --> VSearch[Search villages table<br/>with constraints]
    VSearch --> VMatch{Village Match?}
    VMatch -->|Yes| VValidate[Validate Constraints<br/>Check state/county match]
    VValidate --> VPass{Constraints Pass?}
    VPass -->|Yes| VReturn[Return Village Result<br/>lon, lat, hierarchy]
    VPass -->|No| Boma
    VMatch -->|No| Boma[_try_polygon_match<br/>admin4_boma]
    
    Boma --> BSearch[Search name_index<br/>layer=admin4_boma]
    BSearch --> BMatch{Boma Match?}
    BMatch -->|Yes| BValidate[Validate Constraints<br/>Check spatial hierarchy]
    BValidate --> BPass{Constraints Pass?}
    BPass -->|Yes| BCentroid[Compute Centroid<br/>UTM Zone 36N ‚Üí WGS84]
    BCentroid --> BReturn[Return Boma Result<br/>lon, lat, hierarchy]
    BPass -->|No| Payam
    BMatch -->|No| Payam[_try_polygon_match<br/>admin3_payam]
    
    Payam --> PSearch[Search name_index<br/>layer=admin3_payam]
    PSearch --> PMatch{Payam Match?}
    PMatch -->|Yes| PValidate[Validate Constraints]
    PValidate --> PPass{Constraints Pass?}
    PPass -->|Yes| PCentroid[Compute Centroid]
    PCentroid --> PReturn[Return Payam Result<br/>lon, lat, hierarchy]
    PPass -->|No| County
    PMatch -->|No| County[_try_polygon_match<br/>admin2_county<br/>return_coords=False]
    
    County --> CSearch[Search name_index<br/>layer=admin2_county]
    CSearch --> CMatch{County Match?}
    CMatch -->|Yes| CReturn[Return County Result<br/>resolution_too_coarse=True<br/>lon=None, lat=None]
    CMatch -->|No| NoMatch[Return No Match<br/>score=0.0]
    
    VReturn --> End([End])
    BReturn --> End
    PReturn --> End
    CReturn --> End
    NoMatch --> End
                    </div>
                </div>
            </section>

            <section id="village-search">
                <h2>7. Village Search Process (Detailed)</h2>
                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    Start([search_villages]) --> BuildQuery[Build SQL Query<br/>with Constraints]
    BuildQuery --> ConstraintSQL["WHERE LOWER(county) LIKE '%wau%'<br/>AND ..."]
    ConstraintSQL --> Execute[Execute Query<br/>Get villages in Wau County]
    Execute --> Results{Villages Found?}
    
    Results -->|No| Fallback1[Fallback: Exact County Match]
    Fallback1 --> Fallback2[Fallback: State Only]
    Fallback2 --> Fallback3[Fallback: All Villages]
    Fallback3 --> BuildSearch[Build Search Strings]
    
    Results -->|Yes| BuildSearch[Build Search Strings<br/>from village names]
    
    BuildSearch --> IncludeAlts{Include Alternates?}
    IncludeAlts -->|Yes| QueryAlts[Query village_alternate_names<br/>with constraints]
    QueryAlts --> MergeAlts[Merge with primary names]
    IncludeAlts -->|No| ExactMatch
    MergeAlts --> ExactMatch[Try Exact Match<br/>normalized_query == normalized_name]
    
    ExactMatch --> ExactFound{Exact Match?}
    ExactFound -->|Yes| ReturnExact[Return Exact Match<br/>score=1.0]
    ExactFound -->|No| SubstringMatch[Try Substring Match<br/>query in name or name in query]
    
    SubstringMatch --> SubFound{Good Substring?}
    SubFound -->|Yes| ReturnSub[Return Substring Match<br/>score=0.85-0.95]
    SubFound -->|No| FuzzyMatch[Progressive Fuzzy Match<br/>threshold=0.7]
    
    FuzzyMatch --> FuzzyResults[Get Fuzzy Matches<br/>with scores]
    FuzzyResults --> ContextBoost[Apply Context Boost<br/>+0.20 if county matches<br/>-0.30 if county wrong]
    ContextBoost --> Deduplicate[Deduplicate by village_id<br/>Keep highest score]
    Deduplicate --> Sort[Sort by Score Descending]
    Sort --> Limit[Limit to top N results]
    Limit --> Return[Return Results]
    
    ReturnExact --> End([End])
    ReturnSub --> End
    Return --> End
                    </div>
                </div>

                <h3>Village Search SQL Query Example</h3>
                <pre><code>-- Primary query with constraints
SELECT village_id, name, normalized_name, lon, lat,
       state, county, payam, boma, data_source, verified
FROM villages
WHERE LOWER(county) LIKE LOWER('%wau%')
-- Returns only villages in Wau County

-- If no results, fallback to exact match
SELECT village_id, name, normalized_name, lon, lat,
       state, county, payam, boma, data_source, verified
FROM villages
WHERE LOWER(county) = LOWER('wau')

-- If still no results, try state only
SELECT village_id, name, normalized_name, lon, lat,
       state, county, payam, boma, data_source, verified
FROM villages
WHERE LOWER(state) LIKE LOWER('%western bahr el ghazal%')</code></pre>
            </section>

            <section id="fuzzy-matching">
                <h2>8. Fuzzy Matching Process</h2>
                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    Start([progressive_fuzzy_match]) --> Normalize[Normalize Query<br/>'hai masana area']
    Normalize --> Stage1[Stage 1: Exact Match<br/>Check normalized_query == normalized_choice]
    Stage1 --> Exact{Exact Match?}
    Exact -->|Yes| ReturnExact[Return score=1.0]
    Exact -->|No| Stage2[Stage 2: High Confidence<br/>threshold=0.9]
    
    Stage2 --> Fuzzy1[fuzzy_match<br/>token_sort_ratio + partial_ratio]
    Fuzzy1 --> HighConf{Matches Found?}
    HighConf -->|Yes| LengthCheck[Check Length Ratio<br/>Penalize substring matches]
    LengthCheck --> ReturnHigh[Return High Confidence<br/>score=0.9+]
    HighConf -->|No| Stage3[Stage 3: Medium-High<br/>threshold=0.8]
    
    Stage3 --> Fuzzy2[fuzzy_match<br/>threshold=0.8]
    Fuzzy2 --> MedHigh{Matches Found?}
    MedHigh -->|Yes| ReturnMed[Return Medium-High<br/>score=0.8+]
    MedHigh -->|No| Stage4[Stage 4: Base Threshold<br/>threshold=0.7]
    
    Stage4 --> Fuzzy3[fuzzy_match<br/>threshold=0.7]
    Fuzzy3 --> Base{Matches Found?}
    Base -->|Yes| ReturnBase[Return Base<br/>score=0.7+]
    Base -->|No| Stage5{Query Short?<br/><=2 words or <=5 chars}
    
    Stage5 -->|Yes| Fuzzy4[fuzzy_match<br/>threshold=0.5]
    Stage5 -->|No| ReturnEmpty[Return Empty]
    Fuzzy4 --> Low{Matches Found?}
    Low -->|Yes| ReturnLow[Return Low Confidence<br/>score=0.5+]
    Low -->|No| ReturnEmpty
    
    ReturnExact --> End([End])
    ReturnHigh --> End
    ReturnMed --> End
    ReturnBase --> End
    ReturnLow --> End
    ReturnEmpty --> End
                    </div>
                </div>

                <h3>Fuzzy Matching Algorithms</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Algorithm</th>
                            <th>Description</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>token_sort_ratio</code></td>
                            <td>Sorts tokens, then compares</td>
                            <td>"masana hai" vs "hai masana"</td>
                        </tr>
                        <tr>
                            <td><code>partial_ratio</code></td>
                            <td>Best substring match</td>
                            <td>"masana" in "hai masana area"</td>
                        </tr>
                        <tr>
                            <td><code>WRatio</code></td>
                            <td>Weighted combination</td>
                            <td>Overall best match</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="context-boost">
                <h2>9. Context Boost Application</h2>
                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    Start([apply_context_boost]) --> Init[Initialize boosted_score = base_score]
    Init --> CheckState{State Constraint?}
    CheckState -->|Yes| StateMatch{State Matches?}
    StateMatch -->|Yes| BoostState[+0.20 boost]
    StateMatch -->|No| PenalizeState[-0.50 penalty]
    StateMatch -->|No Match Info| CheckCounty
    BoostState --> CheckCounty
    PenalizeState --> CheckCounty
    CheckState -->|No| CheckCounty{County Constraint?}
    
    CheckCounty -->|Yes| CountyMatch{County Matches?}
    CountyMatch -->|Yes| BoostCounty[+0.20 boost]
    CountyMatch -->|No| PenalizeCounty[-0.30 penalty]
    CountyMatch -->|No Match Info| CheckPayam
    BoostCounty --> CheckPayam
    PenalizeCounty --> CheckPayam
    CheckCounty -->|No| CheckPayam{Payam Constraint?}
    
    CheckPayam -->|Yes| PayamMatch{Payam Matches?}
    PayamMatch -->|Yes| BoostPayam[+0.05 boost]
    PayamMatch -->|No| CheckBoma
    CheckPayam -->|No| CheckBoma{Boma Constraint?}
    
    CheckBoma -->|Yes| BomaMatch{Boma Matches?}
    BomaMatch -->|Yes| BoostBoma[+0.05 boost]
    BomaMatch -->|No| LayerBoost
    CheckBoma -->|No| LayerBoost[Layer Specificity Boost]
    
    LayerBoost --> VillageBoost{Is Village?}
    VillageBoost -->|Yes| +0.15
    VillageBoost -->|No| BomaBoost{Is Boma?}
    BomaBoost -->|Yes| +0.10
    BomaBoost -->|No| PayamBoost{Is Payam?}
    PayamBoost -->|Yes| +0.05
    PayamBoost -->|No| Clamp
    
    +0.15 --> Clamp[Clamp Score<br/>0.0 <= score <= 1.0]
    +0.10 --> Clamp
    +0.05 --> Clamp
    
    Clamp --> Sort[Sort by Boosted Score]
    Sort --> Return[Return Boosted Matches]
    Return --> End([End])
                    </div>
                </div>

                <div class="example-box">
                    <h3>Context Boost Example</h3>
                    <pre><code>Base Match:
  - Query: "hai masana"
  - Village: "Hai Masana"
  - County: "Wau County"
  - Base Score: 0.85

Constraints:
  - county: "wau"

Boost Calculation:
  - Base score: 0.85
  - County matches: +0.20
  - Layer (village): +0.15
  - Final score: 0.85 + 0.20 + 0.15 = 1.20 ‚Üí clamped to 1.0

If county was wrong (e.g., "Juba County"):
  - Base score: 0.85
  - County wrong: -0.30
  - Final score: 0.85 - 0.30 = 0.55 (below threshold, rejected)</code></pre>
                </div>
            </section>

            <section id="example">
                <h2>10. Complete Example: "Hai Masana area, Wau Town, Wau County"</h2>
                <h3>Step-by-Step Execution</h3>
                <div class="diagram-container">
                    <div class="mermaid">
sequenceDiagram
    participant User
    participant Geocoder
    participant Normalizer
    participant Parser
    participant DB
    participant FuzzyMatcher
    
    User->>Geocoder: geocode("Hai Masana area, Wau Town, Wau County")
    Geocoder->>Normalizer: normalize_text()
    Normalizer-->>Geocoder: "hai masana area wau town wau county"
    
    Geocoder->>Parser: parse_hierarchical_constraints()
    Parser-->>Geocoder: {village: "hai masana area", county: "wau"}
    
    Geocoder->>Geocoder: extract_candidates()
    Geocoder-->>Geocoder: {"hai", "masana", "hai masana", "wau", ...}
    
    Geocoder->>DB: Load admin layers
    DB-->>Geocoder: admin_layers loaded
    
    Geocoder->>Geocoder: _try_settlement_match()
    Geocoder->>DB: search_villages("hai masana area", county="wau")
    DB->>DB: WHERE LOWER(county) LIKE '%wau%'
    DB-->>Geocoder: [village1, village2, ...]
    
    Geocoder->>FuzzyMatcher: progressive_fuzzy_match()
    FuzzyMatcher->>FuzzyMatcher: Try exact match
    FuzzyMatcher->>FuzzyMatcher: Try substring match
    FuzzyMatcher->>FuzzyMatcher: Try fuzzy match (threshold=0.7)
    FuzzyMatcher-->>Geocoder: [(village_name, score, idx), ...]
    
    Geocoder->>Geocoder: apply_context_boost()
    Geocoder->>Geocoder: Verify constraints
    Geocoder->>DB: get_village(village_id)
    DB-->>Geocoder: {name, lon, lat, state, county, ...}
    
    Geocoder->>Geocoder: Validate county constraint
    Geocoder-->>User: GeocodeResult(village, lon, lat, hierarchy)
                    </div>
                </div>

                <div class="success-box">
                    <h3>Detailed Execution Trace</h3>
                    <h4>Step 1: Input Processing</h4>
                    <pre><code>Input: "Hai Masana area, Wau Town, Wau County"
‚Üì
Normalized: "hai masana area wau town wau county"</code></pre>

                    <h4>Step 2: Constraint Parsing</h4>
                    <pre><code>Parts: ["Hai Masana area", "Wau Town", "Wau County"]
‚Üì
Constraints:
  - village: "hai masana area" (from first part)
  - county: "wau" (from "Wau County")
  - state: None
  - payam: None
  - boma: None</code></pre>

                    <h4>Step 3: Candidate Extraction</h4>
                    <pre><code>Candidates: {
  "hai", "masana", "area", "wau", "town", "county",
  "hai masana", "masana area", "area wau", "wau town", "wau county",
  "hai masana area", "masana area wau", "area wau town", "wau town wau",
  ...
}</code></pre>

                    <h4>Step 4: Village Search</h4>
                    <pre><code>-- Query executed in DuckDB
SELECT village_id, name, normalized_name, lon, lat,
       state, county, payam, boma
FROM villages
WHERE LOWER(county) LIKE LOWER('%wau%')
-- Returns: [village1, village2, village3, ...]</code></pre>

                    <h4>Step 5: Fuzzy Matching</h4>
                    <pre><code>Query: "hai masana area"
Candidates from DB: ["Hai Masana", "Hai Masana area", "Wau Town", ...]

Matching Process:
1. Exact match: "hai masana area" == "hai masana area" ‚Üí score=1.0 ‚úì
2. If not found, substring: "hai masana" in "hai masana area" ‚Üí score=0.90
3. If not found, fuzzy: token_sort_ratio("hai masana area", "hai masana") ‚Üí score=0.85</code></pre>

                    <h4>Step 6: Context Boost</h4>
                    <pre><code>Base match: "Hai Masana area"
  - Base score: 0.90
  - County constraint: "wau"
  - Village county: "Wau County" ‚úì
  - Boost: +0.20 (county matches)
  - Layer boost: +0.15 (village)
  - Final score: 1.0 (clamped)</code></pre>

                    <h4>Step 7: Constraint Validation</h4>
                    <pre><code>Matched village:
  - name: "Hai Masana area"
  - county: "Wau County"
  - state: "Western Bahr el Ghazal"

Constraints:
  - county: "wau"

Validation:
  - "wau" in "Wau County" ‚Üí ‚úì PASS
  - Return village result</code></pre>

                    <h4>Step 8: Result Construction</h4>
                    <pre><code>GeocodeResult(
    input_text="Hai Masana area, Wau Town, Wau County",
    normalized_text="hai masana area wau town wau county",
    resolved_layer="villages",
    feature_id="abc123...",
    matched_name="Hai Masana area",
    score=1.0,
    lon=28.123456,
    lat=7.654321,
    state="Western Bahr el Ghazal",
    county="Wau County",
    payam="Wau Payam",
    boma="Hai Masana Boma",
    village="Hai Masana area",
    alternatives=[...]
)</code></pre>
                </div>
            </section>

            <section id="data-flow">
                <h2>11. Data Flow Diagram</h2>
                <div class="diagram-container">
                    <div class="mermaid">
graph TB
    subgraph "Input Layer"
        A[User Input String]
    end
    
    subgraph "Processing Layer"
        B[Text Normalization]
        C[Constraint Parsing]
        D[Candidate Extraction]
        E[AI Extraction<br/>Optional]
    end
    
    subgraph "Storage Layer"
        F[(DuckDB Database)]
        G[geocode_cache]
        H[villages]
        I[name_index]
        J[admin1_state]
        K[admin2_county]
        L[admin3_payam]
        M[admin4_boma]
    end
    
    subgraph "Matching Layer"
        N[Exact Match]
        O[Substring Match]
        P[Fuzzy Match]
        Q[Context Boost]
    end
    
    subgraph "Validation Layer"
        R[Constraint Validation]
        S[Spatial Validation]
        T[Hierarchy Lookup]
    end
    
    subgraph "Output Layer"
        U[GeocodeResult]
    end
    
    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    
    F --> G
    F --> H
    F --> I
    F --> J
    F --> K
    F --> L
    F --> M
    
    H --> N
    H --> O
    H --> P
    I --> N
    I --> O
    I --> P
    
    N --> Q
    O --> Q
    P --> Q
    
    Q --> R
    R --> S
    S --> T
    T --> U
    
    U --> G
                    </div>
                </div>
            </section>

            <section id="error-handling">
                <h2>12. Error Handling and Edge Cases</h2>
                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    Start([Geocode Request]) --> CheckInput{Input Valid?}
    CheckInput -->|Empty| ReturnError[Return Error<br/>score=0.0]
    CheckInput -->|Valid| Normalize
    
    Normalize --> CheckCache{Cache Exists?}
    CheckCache -->|Yes| ValidateCache{Cache Valid?}
    ValidateCache -->|Yes| ReturnCache[Return Cached]
    ValidateCache -->|No| Continue
    CheckCache -->|No| Continue[Continue Processing]
    
    Continue --> SearchVillage[Search Villages]
    SearchVillage --> VillageError{Error?}
    VillageError -->|Yes| LogError[Log Error]
    VillageError -->|No| CheckResults{Results Found?}
    
    CheckResults -->|Yes| ValidateConstraints{Constraints Valid?}
    ValidateConstraints -->|No| TryBoma[Try Boma]
    ValidateConstraints -->|Yes| ReturnResult[Return Result]
    
    TryBoma --> BomaError{Error?}
    BomaError -->|Yes| LogError
    BomaError -->|No| BomaResults{Results Found?}
    BomaResults -->|Yes| ReturnResult
    BomaResults -->|No| TryPayam[Try Payam]
    
    TryPayam --> PayamError{Error?}
    PayamError -->|Yes| LogError
    PayamError -->|No| PayamResults{Results Found?}
    PayamResults -->|Yes| ReturnResult
    PayamResults -->|No| TryCounty[Try County]
    
    TryCounty --> CountyError{Error?}
    CountyError -->|Yes| LogError
    CountyError -->|No| CountyResults{Results Found?}
    CountyResults -->|Yes| ReturnCoarse[Return Coarse Result<br/>No coordinates]
    CountyResults -->|No| ReturnNoMatch[Return No Match]
    
    LogError --> ReturnNoMatch
    ReturnError --> End([End])
    ReturnCache --> End
    ReturnResult --> End
    ReturnCoarse --> End
    ReturnNoMatch --> End
                    </div>
                </div>
            </section>

            <section id="performance">
                <h2>13. Performance Considerations</h2>
                <h3>Caching Strategy</h3>
                <div class="diagram-container">
                    <div class="mermaid">
graph LR
    A[Geocode Request] --> B{Has Constraints?}
    B -->|No| C[Check Cache]
    B -->|Yes| D[Skip Cache]
    C --> E{Cache Hit?}
    E -->|Yes| F[Return Cached<br/>~1ms]
    E -->|No| D
    D --> G[Full Processing<br/>~50-200ms]
    G --> H[Cache Result]
    H --> I[Return Result]
    F --> J([End])
    I --> J
                    </div>
                </div>

                <h3>Database Query Optimization</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Query Type</th>
                            <th>Index Used</th>
                            <th>Performance</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Village search by county</td>
                            <td><code>idx_villages_county</code></td>
                            <td>Fast (indexed)</td>
                        </tr>
                        <tr>
                            <td>Village search by name</td>
                            <td><code>idx_villages_name</code></td>
                            <td>Fast (indexed)</td>
                        </tr>
                        <tr>
                            <td>Name index search</td>
                            <td><code>idx_name_index_normalized</code></td>
                            <td>Fast (indexed)</td>
                        </tr>
                        <tr>
                            <td>Spatial hierarchy lookup</td>
                            <td>Spatial index (GeoPandas)</td>
                            <td>Medium (in-memory)</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="summary">
                <h2>14. Summary</h2>
                <div class="success-box">
                    <h3>Key Points</h3>
                    <ol>
                        <li><strong>Text Normalization</strong>: Converts input to searchable format</li>
                        <li><strong>Constraint Parsing</strong>: Extracts hierarchical information (state, county, etc.)</li>
                        <li><strong>Candidate Extraction</strong>: Generates n-grams for matching</li>
                        <li><strong>Hierarchical Resolution</strong>: Tries village ‚Üí boma ‚Üí payam ‚Üí county</li>
                        <li><strong>Fuzzy Matching</strong>: Uses progressive matching (exact ‚Üí substring ‚Üí fuzzy)</li>
                        <li><strong>Context Boost</strong>: Increases scores for matches that align with constraints</li>
                        <li><strong>Constraint Validation</strong>: Ensures results match specified boundaries</li>
                        <li><strong>Caching</strong>: Speeds up repeated queries</li>
                    </ol>
                </div>

                <div class="info-box">
                    <h3>For "Hai Masana area, Wau Town, Wau County"</h3>
                    <ol>
                        <li>‚úÖ Identifies "Wau County" as constraint</li>
                        <li>‚úÖ Searches villages in Wau County only</li>
                        <li>‚úÖ Matches "Hai Masana area" or "Hai Masana"</li>
                        <li>‚úÖ Validates county constraint</li>
                        <li>‚úÖ Returns village coordinates with full hierarchy</li>
                    </ol>
                </div>

                <h3>Code References</h3>
                <div class="example-box">
                    <h4>Key Functions</h4>
                    <ul>
                        <li><code>Geocoder.geocode()</code> - Main entry point</li>
                        <li><code>normalize_text()</code> - Text normalization</li>
                        <li><code>parse_hierarchical_constraints()</code> - Constraint extraction</li>
                        <li><code>extract_candidates()</code> - N-gram generation</li>
                        <li><code>_try_settlement_match()</code> - Village search</li>
                        <li><code>search_villages()</code> - Database village search</li>
                        <li><code>progressive_fuzzy_match()</code> - Fuzzy matching</li>
                        <li><code>apply_context_boost()</code> - Score boosting</li>
                        <li><code>_try_polygon_match()</code> - Polygon layer search</li>
                    </ul>

                    <h4>Configuration</h4>
                    <ul>
                        <li><code>FUZZY_THRESHOLD = 0.7</code> - Minimum match score</li>
                        <li><code>LAYER_NAMES</code> - Admin layer names</li>
                        <li><code>CENTROID_CRS = "EPSG:32736"</code> - UTM Zone 36N for South Sudan</li>
                    </ul>
                </div>
            </section>
        </main>

        <a href="#" class="back-to-top" title="Back to top">‚Üë</a>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Back to top button
        const backToTop = document.querySelector('.back-to-top');
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTop.style.display = 'flex';
            } else {
                backToTop.style.display = 'none';
            }
        });

        backToTop.addEventListener('click', (e) => {
            e.preventDefault();
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    </script>
</body>
</html>


